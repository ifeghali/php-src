* unicode in `..`?

* EBCDIC support?

* Discuss putting ZEND_ATTRIBUTE_FORMAT back on zend_error() or create a new
  zend_error_ex() function that supports new specifiers

* Finalize zend_hash_get_current_key_ex() discussion. We probably need to
  have zend_u_hash_get_current_key_ex() and have the old function proxy to it.
  The question is what happens when an IS_UNICODE key is present and the old
  function is called.

* use zend_literal_to_unicode when comparing "this" and such

* fix string offset operator to work only on strings, and array offset one
  to work only on arrays

* Should we apply identifier validity checks in functions that deal with
  identifiers, such as define(), get_class(), etc?

* Resolve the differences in %G output format. sprintf() removes trailing
  zeroes from the fractional part, and u_sprintf() doesn't.

* Determine how to deal with filesystem and filenames when Unicode is
  involved. This concerns both the extension functions and things like
  compile_file(), open_file_for_scanning(), etc.

* Use U_STRING_DECL/U_STRING/INIT for initializing literals possibly.

* Measure performance difference when doing quickCheck + normalize versus
  simple normalize.

* Find all instances where unicode strings are compare with memcmp() and
  replace either with u_memcmpCodePointOrder() or ucol_strcoll()

* Opening a collator may return U_USING_DEFAULT_WARNING,
  U_USING_FALLBACK_WARNING

* Need to make http input work as described in the design doc.

* Solve ZTS issues. Some extensions store pointers to internal 
  zend_class_entries during extension startup, but these pointers can be changed
  from request to request (dependent on "unicode" setting). Right now these
  pointers are reinitialized during request startup but they are still stored
  in real global variables. Probably the problem should be solved in other way
  or pinters to zend_class_entries should be stored in module globals.

* output.c needs a lot of work as it passes char* around

* Require and/or bundle ICU 3.4.

* Right now if a function passes "TT" to zend_parse_parameters(), and one of
  the arguments is IS_BINARY, then all of the rest of T arguments are
  converted to IS_BINARY as well. I will modify it so that if one of the other
  arguments is IS_UNICODE then we generate an error and abort parsing. If we
  do run across a function that really needs to accept IS_BINARY as one
  argument and IS_UNICODE as another, then we can use "bu" for the parsing
  format.

* Comparison operators should act similar to concatenation one, check the
  types and coerce when necessary.
